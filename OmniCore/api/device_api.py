# coding: utf-8

"""
    OmniCore Model and State Management API

    This is an OmniCore Model and State Management server.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: omnicoresupport@korewireless.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr

from typing import Any, Dict, List, Optional

from OmniCore.models.bind_request import BindRequest
from OmniCore.models.bind_request_ids_gateway import BindRequestIdsGateway
from OmniCore.models.block_communication_body import BlockCommunicationBody
from OmniCore.models.custom_onboard import CustomOnboard
from OmniCore.models.device import Device
from OmniCore.models.device_command import DeviceCommand
from OmniCore.models.device_config import DeviceConfig
from OmniCore.models.device_configuration import DeviceConfiguration
from OmniCore.models.info import Info
from OmniCore.models.list_device_config_versions_response import ListDeviceConfigVersionsResponse
from OmniCore.models.list_device_states_response import ListDeviceStatesResponse
from OmniCore.models.list_devices_response import ListDevicesResponse

from OmniCore.api_client import ApiClient
from OmniCore.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DeviceApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def bind_device(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequest, Field(..., description="application/json")], **kwargs) -> Info:  # noqa: E501
        """bind_device  # noqa: E501

        Bind  a device to a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_device(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.bind_device_with_http_info(subscription_id, registry_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def bind_device_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequest, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """bind_device  # noqa: E501

        Bind  a device to a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_device_with_http_info(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bind_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/bindDeviceToGateway', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def bind_devices(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequestIdsGateway, Field(..., description="application/json")], **kwargs) -> Info:  # noqa: E501
        """bind_devices  # noqa: E501

        Bind devices to a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_devices(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequestIdsGateway
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.bind_devices_with_http_info(subscription_id, registry_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def bind_devices_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequestIdsGateway, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """bind_devices  # noqa: E501

        Bind devices to a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_devices_with_http_info(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequestIdsGateway
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bind_devices" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/bindDevicesToGateway', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def block_device_communcation(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[BlockCommunicationBody, Field(..., description="application/json")], **kwargs) -> object:  # noqa: E501
        """block_device_communcation  # noqa: E501

        Blocks All Communication From A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.block_device_communcation(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: BlockCommunicationBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.block_device_communcation_with_http_info(subscriptionid, registry_id, device_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def block_device_communcation_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[BlockCommunicationBody, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """block_device_communcation  # noqa: E501

        Blocks All Communication From A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.block_device_communcation_with_http_info(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: BlockCommunicationBody
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method block_device_communcation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/communication', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_device(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[Device, Field(..., description="application/json")], **kwargs) -> Device:  # noqa: E501
        """create_device  # noqa: E501

        Create a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: Device
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Device
        """
        kwargs['_return_http_data_only'] = True
        return self.create_device_with_http_info(subscription_id, registry_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def create_device_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[Device, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """create_device  # noqa: E501

        Create a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device_with_http_info(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: Device
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Device, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Device",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/devices', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def delete_device(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], **kwargs) -> Info:  # noqa: E501
        """delete_device  # noqa: E501

        Delete a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_device(subscription_id, registry_id, device_id, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_device_with_http_info(subscription_id, registry_id, device_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_device_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], **kwargs):  # noqa: E501
        """delete_device  # noqa: E501

        Delete a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_device_with_http_info(subscription_id, registry_id, device_id, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/devices/{deviceId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_config(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], num_versions : Annotated[Optional[StrictInt], Field(description="The number of versions to list. Versions are listed in decreasing order of the version number. The maximum number of versions retained is 10. If this value is zero, it will return all the versions available.")] = None, **kwargs) -> ListDeviceConfigVersionsResponse:  # noqa: E501
        """get_config  # noqa: E501

        Get Configs Of Devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_config(subscriptionid, registry_id, device_id, num_versions, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param num_versions: The number of versions to list. Versions are listed in decreasing order of the version number. The maximum number of versions retained is 10. If this value is zero, it will return all the versions available.
        :type num_versions: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDeviceConfigVersionsResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_config_with_http_info(subscriptionid, registry_id, device_id, num_versions, **kwargs)  # noqa: E501

    @validate_arguments
    def get_config_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], num_versions : Annotated[Optional[StrictInt], Field(description="The number of versions to list. Versions are listed in decreasing order of the version number. The maximum number of versions retained is 10. If this value is zero, it will return all the versions available.")] = None, **kwargs):  # noqa: E501
        """get_config  # noqa: E501

        Get Configs Of Devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_config_with_http_info(subscriptionid, registry_id, device_id, num_versions, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param num_versions: The number of versions to list. Versions are listed in decreasing order of the version number. The maximum number of versions retained is 10. If this value is zero, it will return all the versions available.
        :type num_versions: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDeviceConfigVersionsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'num_versions'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []
        if _params.get('num_versions') is not None:  # noqa: E501
            _query_params.append(('numVersions', _params['num_versions']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDeviceConfigVersionsResponse",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/configVersions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_device(self, registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], **kwargs) -> Device:  # noqa: E501
        """get_device  # noqa: E501

        Get a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_device(registry_id, subscription_id, device_id, async_req=True)
        >>> result = thread.get()

        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Device
        """
        kwargs['_return_http_data_only'] = True
        return self.get_device_with_http_info(registry_id, subscription_id, device_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_device_with_http_info(self, registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], **kwargs):  # noqa: E501
        """get_device  # noqa: E501

        Get a device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_device_with_http_info(registry_id, subscription_id, device_id, async_req=True)
        >>> result = thread.get()

        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Device, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'registry_id',
            'subscription_id',
            'device_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Device",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/devices/{deviceId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_devices(self, registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], page_number : Annotated[Optional[StrictInt], Field(description="Page Number")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The maximum number of devices to return in the response. If this value is zero, the service will select a default size. ")] = None, field_mask : Annotated[Optional[StrictStr], Field(description="The fields of the Device resource to be returned to the response. The fields id and numId are always returned, along with any other fields specified. A comma-separated list of fully qualified names of fields. Example: ")] = None, device_ids : Annotated[Optional[List[StrictStr]], Field(description="A list of device string IDs. For example, ['device0', 'device12']. If empty, this field is ignored. Maximum IDs: 10,000")] = None, device_num_ids : Annotated[Optional[List[StrictStr]], Field(description="A list of device numeric IDs. If empty, this field is ignored. Maximum IDs: 10,000.")] = None, gateway_list_options_associations_device_id : Annotated[Optional[StrictStr], Field(description="If set, returns only the gateways with which the specified device is associated. The device ID can be numeric (num_id) or the user-defined string (id). For example, if 456 is specified, returns only the gateways to which the device with num_id 456 is bound.")] = None, gateway_list_options_associations_gateway_id : Annotated[Optional[StrictStr], Field(description="If set, only devices associated with the specified gateway are returned. The gateway ID can be numeric (num_id) or the user-defined string (id). For example, if 123 is specified, only devices bound to the gateway with num_id 123 are returned")] = None, gateway_list_options_gateway_type : Annotated[Optional[StrictStr], Field(description="If GATEWAY is specified, only gateways are returned. If NON_GATEWAY is specified, only non-gateway devices are returned. If GATEWAY_TYPE_UNSPECIFIED is specified, all devices are returned.")] = None, **kwargs) -> ListDevicesResponse:  # noqa: E501
        """get_devices  # noqa: E501

        Get all devices under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_devices(registry_id, subscription_id, page_number, page_size, field_mask, device_ids, device_num_ids, gateway_list_options_associations_device_id, gateway_list_options_associations_gateway_id, gateway_list_options_gateway_type, async_req=True)
        >>> result = thread.get()

        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param page_number: Page Number
        :type page_number: int
        :param page_size: The maximum number of devices to return in the response. If this value is zero, the service will select a default size. 
        :type page_size: int
        :param field_mask: The fields of the Device resource to be returned to the response. The fields id and numId are always returned, along with any other fields specified. A comma-separated list of fully qualified names of fields. Example: 
        :type field_mask: str
        :param device_ids: A list of device string IDs. For example, ['device0', 'device12']. If empty, this field is ignored. Maximum IDs: 10,000
        :type device_ids: List[str]
        :param device_num_ids: A list of device numeric IDs. If empty, this field is ignored. Maximum IDs: 10,000.
        :type device_num_ids: List[str]
        :param gateway_list_options_associations_device_id: If set, returns only the gateways with which the specified device is associated. The device ID can be numeric (num_id) or the user-defined string (id). For example, if 456 is specified, returns only the gateways to which the device with num_id 456 is bound.
        :type gateway_list_options_associations_device_id: str
        :param gateway_list_options_associations_gateway_id: If set, only devices associated with the specified gateway are returned. The gateway ID can be numeric (num_id) or the user-defined string (id). For example, if 123 is specified, only devices bound to the gateway with num_id 123 are returned
        :type gateway_list_options_associations_gateway_id: str
        :param gateway_list_options_gateway_type: If GATEWAY is specified, only gateways are returned. If NON_GATEWAY is specified, only non-gateway devices are returned. If GATEWAY_TYPE_UNSPECIFIED is specified, all devices are returned.
        :type gateway_list_options_gateway_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDevicesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_devices_with_http_info(registry_id, subscription_id, page_number, page_size, field_mask, device_ids, device_num_ids, gateway_list_options_associations_device_id, gateway_list_options_associations_gateway_id, gateway_list_options_gateway_type, **kwargs)  # noqa: E501

    @validate_arguments
    def get_devices_with_http_info(self, registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], page_number : Annotated[Optional[StrictInt], Field(description="Page Number")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The maximum number of devices to return in the response. If this value is zero, the service will select a default size. ")] = None, field_mask : Annotated[Optional[StrictStr], Field(description="The fields of the Device resource to be returned to the response. The fields id and numId are always returned, along with any other fields specified. A comma-separated list of fully qualified names of fields. Example: ")] = None, device_ids : Annotated[Optional[List[StrictStr]], Field(description="A list of device string IDs. For example, ['device0', 'device12']. If empty, this field is ignored. Maximum IDs: 10,000")] = None, device_num_ids : Annotated[Optional[List[StrictStr]], Field(description="A list of device numeric IDs. If empty, this field is ignored. Maximum IDs: 10,000.")] = None, gateway_list_options_associations_device_id : Annotated[Optional[StrictStr], Field(description="If set, returns only the gateways with which the specified device is associated. The device ID can be numeric (num_id) or the user-defined string (id). For example, if 456 is specified, returns only the gateways to which the device with num_id 456 is bound.")] = None, gateway_list_options_associations_gateway_id : Annotated[Optional[StrictStr], Field(description="If set, only devices associated with the specified gateway are returned. The gateway ID can be numeric (num_id) or the user-defined string (id). For example, if 123 is specified, only devices bound to the gateway with num_id 123 are returned")] = None, gateway_list_options_gateway_type : Annotated[Optional[StrictStr], Field(description="If GATEWAY is specified, only gateways are returned. If NON_GATEWAY is specified, only non-gateway devices are returned. If GATEWAY_TYPE_UNSPECIFIED is specified, all devices are returned.")] = None, **kwargs):  # noqa: E501
        """get_devices  # noqa: E501

        Get all devices under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_devices_with_http_info(registry_id, subscription_id, page_number, page_size, field_mask, device_ids, device_num_ids, gateway_list_options_associations_device_id, gateway_list_options_associations_gateway_id, gateway_list_options_gateway_type, async_req=True)
        >>> result = thread.get()

        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param page_number: Page Number
        :type page_number: int
        :param page_size: The maximum number of devices to return in the response. If this value is zero, the service will select a default size. 
        :type page_size: int
        :param field_mask: The fields of the Device resource to be returned to the response. The fields id and numId are always returned, along with any other fields specified. A comma-separated list of fully qualified names of fields. Example: 
        :type field_mask: str
        :param device_ids: A list of device string IDs. For example, ['device0', 'device12']. If empty, this field is ignored. Maximum IDs: 10,000
        :type device_ids: List[str]
        :param device_num_ids: A list of device numeric IDs. If empty, this field is ignored. Maximum IDs: 10,000.
        :type device_num_ids: List[str]
        :param gateway_list_options_associations_device_id: If set, returns only the gateways with which the specified device is associated. The device ID can be numeric (num_id) or the user-defined string (id). For example, if 456 is specified, returns only the gateways to which the device with num_id 456 is bound.
        :type gateway_list_options_associations_device_id: str
        :param gateway_list_options_associations_gateway_id: If set, only devices associated with the specified gateway are returned. The gateway ID can be numeric (num_id) or the user-defined string (id). For example, if 123 is specified, only devices bound to the gateway with num_id 123 are returned
        :type gateway_list_options_associations_gateway_id: str
        :param gateway_list_options_gateway_type: If GATEWAY is specified, only gateways are returned. If NON_GATEWAY is specified, only non-gateway devices are returned. If GATEWAY_TYPE_UNSPECIFIED is specified, all devices are returned.
        :type gateway_list_options_gateway_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDevicesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'registry_id',
            'subscription_id',
            'page_number',
            'page_size',
            'field_mask',
            'device_ids',
            'device_num_ids',
            'gateway_list_options_associations_device_id',
            'gateway_list_options_associations_gateway_id',
            'gateway_list_options_gateway_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_devices" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']

        # process the query parameters
        _query_params = []
        if _params.get('page_number') is not None:  # noqa: E501
            _query_params.append(('pageNumber', _params['page_number']))
        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))
        if _params.get('field_mask') is not None:  # noqa: E501
            _query_params.append(('fieldMask', _params['field_mask']))
        if _params.get('device_ids') is not None:  # noqa: E501
            _query_params.append(('deviceIds', _params['device_ids']))
            _collection_formats['deviceIds'] = 'csv'
        if _params.get('device_num_ids') is not None:  # noqa: E501
            _query_params.append(('deviceNumIds', _params['device_num_ids']))
            _collection_formats['deviceNumIds'] = 'csv'
        if _params.get('gateway_list_options_associations_device_id') is not None:  # noqa: E501
            _query_params.append(('gatewayListOptions.associationsDeviceId', _params['gateway_list_options_associations_device_id']))
        if _params.get('gateway_list_options_associations_gateway_id') is not None:  # noqa: E501
            _query_params.append(('gatewayListOptions.associationsGatewayId', _params['gateway_list_options_associations_gateway_id']))
        if _params.get('gateway_list_options_gateway_type') is not None:  # noqa: E501
            _query_params.append(('gatewayListOptions.gatewayType', _params['gateway_list_options_gateway_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDevicesResponse",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/devices', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_states(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], num_states : Annotated[Optional[StrictInt], Field(description="The number of states to list. States are listed in descending order of update time. The maximum number of states retained is 10. If this value is zero, it will return all the states available.")] = None, **kwargs) -> ListDeviceStatesResponse:  # noqa: E501
        """get_states  # noqa: E501

        Get States Of Devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_states(subscriptionid, registry_id, device_id, num_states, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param num_states: The number of states to list. States are listed in descending order of update time. The maximum number of states retained is 10. If this value is zero, it will return all the states available.
        :type num_states: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDeviceStatesResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_states_with_http_info(subscriptionid, registry_id, device_id, num_states, **kwargs)  # noqa: E501

    @validate_arguments
    def get_states_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], num_states : Annotated[Optional[StrictInt], Field(description="The number of states to list. States are listed in descending order of update time. The maximum number of states retained is 10. If this value is zero, it will return all the states available.")] = None, **kwargs):  # noqa: E501
        """get_states  # noqa: E501

        Get States Of Devices  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_states_with_http_info(subscriptionid, registry_id, device_id, num_states, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param num_states: The number of states to list. States are listed in descending order of update time. The maximum number of states retained is 10. If this value is zero, it will return all the states available.
        :type num_states: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDeviceStatesResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'num_states'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_states" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []
        if _params.get('num_states') is not None:  # noqa: E501
            _query_params.append(('numStates', _params['num_states']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDeviceStatesResponse",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/states', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def send_command_to_device(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[DeviceCommand, Field(..., description="application/json")], **kwargs) -> object:  # noqa: E501
        """send_command_to_device  # noqa: E501

        Send A Command To A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_command_to_device(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: DeviceCommand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        return self.send_command_to_device_with_http_info(subscriptionid, registry_id, device_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def send_command_to_device_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[DeviceCommand, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """send_command_to_device  # noqa: E501

        Send A Command To A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_command_to_device_with_http_info(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: DeviceCommand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_command_to_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/sendCommandToDevice', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def un_bind_device(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequest, Field(..., description="application/json")], **kwargs) -> Info:  # noqa: E501
        """un_bind_device  # noqa: E501

        UnBind  a device from a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.un_bind_device(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.un_bind_device_with_http_info(subscription_id, registry_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def un_bind_device_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequest, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """un_bind_device  # noqa: E501

        UnBind  a device from a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.un_bind_device_with_http_info(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method un_bind_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/unbindDeviceFromGateway', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def un_bind_devices(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequestIdsGateway, Field(..., description="application/json")], **kwargs) -> Info:  # noqa: E501
        """un_bind_devices  # noqa: E501

        UnBind devices from a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.un_bind_devices(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequestIdsGateway
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.un_bind_devices_with_http_info(subscription_id, registry_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def un_bind_devices_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device : Annotated[BindRequestIdsGateway, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """un_bind_devices  # noqa: E501

        UnBind devices from a gateway under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.un_bind_devices_with_http_info(subscription_id, registry_id, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device: application/json (required)
        :type device: BindRequestIdsGateway
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method un_bind_devices" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/unbindDevicesFromGateway', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_configuration_to_device(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[DeviceConfiguration, Field(..., description="application/json")], **kwargs) -> DeviceConfig:  # noqa: E501
        """update_configuration_to_device  # noqa: E501

        Update A Configuration Of A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_configuration_to_device(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: DeviceConfiguration
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeviceConfig
        """
        kwargs['_return_http_data_only'] = True
        return self.update_configuration_to_device_with_http_info(subscriptionid, registry_id, device_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def update_configuration_to_device_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[DeviceConfiguration, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """update_configuration_to_device  # noqa: E501

        Update A Configuration Of A Device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_configuration_to_device_with_http_info(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: DeviceConfiguration
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeviceConfig, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_configuration_to_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "DeviceConfig",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/updateConfigurationToDevice', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_custom_onboard_request(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[CustomOnboard, Field(..., description="application/json")], **kwargs) -> Info:  # noqa: E501
        """update_custom_onboard_request  # noqa: E501

        Approve/Reject a Custom Onboard Request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_custom_onboard_request(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: CustomOnboard
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Info
        """
        kwargs['_return_http_data_only'] = True
        return self.update_custom_onboard_request_with_http_info(subscriptionid, registry_id, device_id, device, **kwargs)  # noqa: E501

    @validate_arguments
    def update_custom_onboard_request_with_http_info(self, subscriptionid : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], device : Annotated[CustomOnboard, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """update_custom_onboard_request  # noqa: E501

        Approve/Reject a Custom Onboard Request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_custom_onboard_request_with_http_info(subscriptionid, registry_id, device_id, device, async_req=True)
        >>> result = thread.get()

        :param subscriptionid: Subscription ID (required)
        :type subscriptionid: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param device: application/json (required)
        :type device: CustomOnboard
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Info, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscriptionid',
            'registry_id',
            'device_id',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_onboard_request" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscriptionid']:
            _path_params['subscriptionid'] = _params['subscriptionid']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Info",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionid}/registries/{registryId}/devices/{deviceId}/updateCustomOnboardRequest', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_device(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], update_mask : Annotated[StrictStr, Field(..., description="Required. Only updates the device fields indicated by this mask. The field mask must not be empty, and it must not contain fields that are immutable or only set by the server. Mutable top-level fields: credentials,logLevel, blocked,policy and metadata")], device : Annotated[Device, Field(..., description="application/json")], **kwargs) -> Device:  # noqa: E501
        """update_device  # noqa: E501

        Modify device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_device(subscription_id, registry_id, device_id, update_mask, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param update_mask: Required. Only updates the device fields indicated by this mask. The field mask must not be empty, and it must not contain fields that are immutable or only set by the server. Mutable top-level fields: credentials,logLevel, blocked,policy and metadata (required)
        :type update_mask: str
        :param device: application/json (required)
        :type device: Device
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Device
        """
        kwargs['_return_http_data_only'] = True
        return self.update_device_with_http_info(subscription_id, registry_id, device_id, update_mask, device, **kwargs)  # noqa: E501

    @validate_arguments
    def update_device_with_http_info(self, subscription_id : Annotated[StrictStr, Field(..., description="Subscription ID")], registry_id : Annotated[StrictStr, Field(..., description="Registry ID")], device_id : Annotated[StrictStr, Field(..., description="Device ID")], update_mask : Annotated[StrictStr, Field(..., description="Required. Only updates the device fields indicated by this mask. The field mask must not be empty, and it must not contain fields that are immutable or only set by the server. Mutable top-level fields: credentials,logLevel, blocked,policy and metadata")], device : Annotated[Device, Field(..., description="application/json")], **kwargs):  # noqa: E501
        """update_device  # noqa: E501

        Modify device under a registry  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_device_with_http_info(subscription_id, registry_id, device_id, update_mask, device, async_req=True)
        >>> result = thread.get()

        :param subscription_id: Subscription ID (required)
        :type subscription_id: str
        :param registry_id: Registry ID (required)
        :type registry_id: str
        :param device_id: Device ID (required)
        :type device_id: str
        :param update_mask: Required. Only updates the device fields indicated by this mask. The field mask must not be empty, and it must not contain fields that are immutable or only set by the server. Mutable top-level fields: credentials,logLevel, blocked,policy and metadata (required)
        :type update_mask: str
        :param device: application/json (required)
        :type device: Device
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Device, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'subscription_id',
            'registry_id',
            'device_id',
            'update_mask',
            'device'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['subscription_id']:
            _path_params['subscriptionId'] = _params['subscription_id']
        if _params['registry_id']:
            _path_params['registryId'] = _params['registry_id']
        if _params['device_id']:
            _path_params['deviceId'] = _params['device_id']

        # process the query parameters
        _query_params = []
        if _params.get('update_mask') is not None:  # noqa: E501
            _query_params.append(('updateMask', _params['update_mask']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params['device']:
            _body_params = _params['device']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['apiKey', 'bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "Device",
            '400': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '500': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/subscriptions/{subscriptionId}/registries/{registryId}/devices/{deviceId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
